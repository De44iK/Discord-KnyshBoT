# KnyshBoT Discord Project by @De44iK aka Denys Podolkhov
# Feel free to copy, use and modify this code
# Version: BotOS 0.31.3 User Experience Update

from secret import BOT_TOKEN_RELEASE, BOT_TOKEN_TESTING, WEATHER_API_KEY
from config import BOT_PREFIX, BOT_MODE
from discord.ui import Button, View
from discord import Embed, Color
from discord.ext import commands
from typing import List
import contextlib
import traceback
import requests
import datetime
import discord
import asyncio
import qrcode
import random
import time
import json
import os
import io


intents = discord.Intents.all()
intents.message_content = True
bot = commands.Bot(command_prefix=BOT_PREFIX, intents=intents, help_command=None)

color_list = [
    Color.default(),
    Color.teal(),
    Color.dark_teal(),
    Color.green(),
    Color.dark_green(),
    Color.blue(),
    Color.dark_blue(),
    Color.purple(),
    Color.dark_purple(),
    Color.magenta(),
    Color.dark_magenta(),
    Color.gold(),
    Color.dark_gold(),
    Color.orange(),
    Color.dark_orange(),
    Color.red(),
    Color.dark_red(),
    Color.lighter_grey(),
    Color.light_grey(),
    Color.dark_grey(),
    Color.darker_grey(),
    Color.blurple(),
    Color.greyple(),
    Color.red() 
]

embedCMDS = Embed(
    title="–ö–æ–º–∞–Ω–¥—ã KnyshBoT",
    description="–í–æ—Ç —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–æ–º–∞–Ω–¥: ",
    color=Color.blue(),  # Blue color for the embed
)
embedCMDS.add_field(name="/menu", value="üí¨ –û—Ç–∫—Ä—ã—Ç—å —Å—Ç–∞—Ä—Ç–æ–≤–æ–µ –º–µ–Ω—é", inline=False)
embedCMDS.add_field(name="/test", value="üü¢ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–Ω–ª–∞–π–Ω –ª–∏ –±–æ—Ç", inline=False)
embedCMDS.add_field(name="/ping", value="üåê –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–∫–æ—Ä–æ—Å—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å –±–æ—Ç–æ–º", inline=False)
embedCMDS.add_field(name="/qr", value="üî≥ –°–æ–∑–¥–∞—Ç—å qr-–∫–æ–¥ —Å –ª—é–±–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π", inline=False)
embedCMDS.add_field(name="/code", value="üíª –ó–∞–ø—É—Å—Ç–∏—Ç—å –∫–æ–¥ –Ω–∞ Python –ø—Ä—è–º–æ –≤ —á–∞—Ç–µ", inline=False)
embedCMDS.add_field(name="/cmds", value="üßæ –û—Ç–∫—Ä—ã—Ç—å —Å–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥ –≤ –æ–±—Ö–æ–¥ –º–µ–Ω—é", inline=False)
embedCMDS.add_field(name="/advt", value="‚ùó –°–æ–∑–¥–∞—Ç—å –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –æ—Ç –∏–º–µ–Ω–∏ –ì–ª–∞–≤–Ω–æ–≥–æ –ë–æ—Ç–∞", inline=False)
embedCMDS.add_field(name="/cls", value="üéµ –û—á–∏—Å—Ç–∏—Ç—å —á–∞—Ç (—Ç–æ–ª—å–∫–æ –¥–ª—è –º—É–∑—ã–∫–∞–ª—å–Ω–æ–≥–æ —á–∞—Ç–∞)", inline=False)
embedCMDS.add_field(name="/tic", value="‚≠ï –°—ã–≥—Ä–∞—Ç—å –≤ –ö—Ä–µ—Å—Ç–∏–∫–∏-–ù–æ–ª–∏–∫–∏", inline=False)
embedCMDS.add_field(name="/w", value="üå• –£–∑–Ω–∞—Ç—å –ø–æ–≥–æ–¥—É –≤ –ª—é–±–æ–º –≥–æ—Ä–æ–¥–µ", inline=False)


@bot.command()
async def cmds(ctx):
    await ctx.send(embed=embedCMDS)


@bot.command()
async def test(ctx):
    testPhrases = [
        f"–Ø –∂–∏–≤–æ–π –Ω–µ –ø–∞—Ä—å—Å—è, {ctx.author.mention}",
        "—è —Ç—É—Ç",
        "—à–æ –Ω–∞–¥–æ",
        "—è —Å–ª—É—à–∞—é",
        "–æ –¥–∞, –∞–¥–º–∏–Ω –≤ —á–∞—Ç–µ",
    ]
    await ctx.send(random.choice(testPhrases))


def create_error_embed(error_message):
    embed = discord.Embed(
        title="Error", description=error_message, color=discord.Color.red()
    )
    return embed


# Command: Run Python code
@bot.command()
async def code(ctx):
    await ctx.send("Write your code here and send to debug")

    def check(msg):
        return msg.author == ctx.author and msg.content != "/code"

    code_msg = await bot.wait_for("message", check=check)

    # Create an environment to capture stdout
    old_stdout = io.StringIO()
    new_stdout = io.StringIO()
    code = code_msg.content

    try:
        with contextlib.redirect_stdout(new_stdout):
            exec(code)

        stdout_value = new_stdout.getvalue()
        if stdout_value:
            await ctx.send(stdout_value)
    except Exception as e:
        traceback_msg = traceback.format_exception(type(e), e, e.__traceback__)
        traceback_str = "".join(traceback_msg)

        # Create and send the error embed
        error_embed = create_error_embed(f"\n```\n{traceback_str}\n```")
        await ctx.send(embed=error_embed)


@bot.command()
async def ping(ctx):
    # Calculate the bot's latency
    bot_latency = round(bot.latency * 1000)  # Convert to milliseconds

    # Record the time when the user's message was received
    start_time = time.time()

    # Send a temporary message to calculate round-trip time
    temp_message = await ctx.send("Calculating ping...")

    # Calculate round-trip time (time taken from sending to receiving the temporary message)
    round_trip_time = round((time.time() - start_time) * 1000)
    img = "üü¢"
    if round_trip_time > 240:
        img = "üü°"
    if round_trip_time > 300:
        img = "üî¥"
    # Edit the temporary message to display ping results
    await temp_message.edit(content=f"{img} Ping is: {round_trip_time}ms")


@bot.command()
async def advt(ctx: commands.Context, *, args):
    try:
        result = str(args)
        channel = ctx.channel

        async for message in channel.history(limit=1):
            await message.delete()
        phrases = ["–û–±—ä—è–≤–ª–µ–Ω–∏–µ –æ—Ç: ", "–° –ª—é–±–æ–≤—å—é, –≤–∞—à ", "–≠—Ç–æ –Ω–∞–ø–∏—Å–∞–ª ", "–í–∞—Å —É–≤–µ–¥–æ–º–ª—è–µ—Ç ", "–ü–∏—à–µ—Ç –∞–¥–º–∏–Ω—á–∏–∫ "]
        await ctx.send(
            embed=discord.Embed(
                title=f"{result}",
                description= random.choice(phrases)+f"{ctx.author.name}",
                color=random.choice(color_list)
            )
        )
    except Exception:
        embed = discord.Embed(
            title="–û—à–∏–±–∫–∞",
            description='–û–±—å—è–≤–ª–µ–Ω–∏—è –¥–æ—Å—Ç—É–ø–Ω—ã —Ç–æ–ª—å–∫–æ –¥–ª—è –∫–∞–Ω–∞–ª–æ–≤ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–∞—Ö',
            color=0xFC2403,
        )
        await ctx.send(embed=embed)

@bot.command()
async def qr(ctx, *, args):
    data = str(args).replace(" ", "_")

    # Generate the QR code image
    qr = qrcode.QRCode(
        version=1,
        error_correction=qrcode.constants.ERROR_CORRECT_H,
        box_size=10,
        border=4,
    )
    qr.add_data(data)
    qr.make(fit=True)

    # Create a discord.File object from the QR code image
    qr_image = qr.make_image(fill_color="black", back_color="white")
    qr_filename = "qr_code.png"
    qr_image.save(qr_filename)
    qr_file = discord.File(qr_filename)

    # Send the QR code image as a message
    await ctx.send(file=qr_file)

    # Delete the temporary QR code image file
    qr_image.close()
    os.remove(qr_filename)


@qr.error
async def make_qr_code_error(ctx, error):
    if isinstance(error, commands.MissingRequiredArgument):
        embed = discord.Embed(
            title="–û—à–∏–±–∫–∞",
            description='–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—Ç—å–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è qr-–∫–æ–¥–∞ –ø–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã.\n–ü—Ä–∏–º–µ—Ä: "/qr www.example.com"',
            color=0xFC2403,
        )
        await ctx.send(embed=embed)


class TicTacToeButton(discord.ui.Button["TicTacToe"]):
    def __init__(self, x: int, y: int):
        # A label is required, but we don't need one so a zero-width space is used
        # The row parameter tells the View which row to place the button under.
        # A View can only contain up to 5 rows -- each row can only have 5 buttons.
        # Since a Tic Tac Toe grid is 3x3 that means we have 3 rows and 3 columns.
        super().__init__(style=discord.ButtonStyle.secondary, label="\u200b", row=y)
        self.x = x
        self.y = y

    # This function is called whenever this particular button is pressed
    # This is part of the "meat" of the game logic
    async def callback(self, interaction: discord.Interaction):
        assert self.view is not None
        view: TicTacToe = self.view
        state = view.board[self.y][self.x]
        if state in (view.X, view.O):
            return

        if view.current_player == view.X:
            self.style = discord.ButtonStyle.danger
            self.label = "X"
            self.disabled = True
            view.board[self.y][self.x] = view.X
            view.current_player = view.O
            content = "–•–æ–¥–∏—Ç —á–µ–ª —Å –û:"
        else:
            self.style = discord.ButtonStyle.success
            self.label = "O"
            self.disabled = True
            view.board[self.y][self.x] = view.O
            view.current_player = view.X
            content = "–•–æ–¥–∏—Ç —á–µ–ª —Å –•:"

        winner = view.check_board_winner()
        if winner is not None:
            if winner == view.X:
                content = "–ü–æ–±–µ–¥–∏–ª –•!"
            elif winner == view.O:
                content = "–ü–æ–±–µ–¥–∏–ª —á–µ–ª —Å –û!"
            else:
                content = "–ù–∏—á—å—è, –ø–æ–±–µ–¥–∏–ª–∞ –¥—Ä—É–∂–±–∞!!"

            for child in view.children:
                child.disabled = True

            view.stop()

        await interaction.response.edit_message(content=content, view=view)


# This is our actual board View
class TicTacToe(discord.ui.View):
    # This tells the IDE or linter that all our children will be TicTacToeButtons
    # This is not required
    children: List[TicTacToeButton]
    X = -1
    O = 1
    Tie = 2

    def __init__(self):
        super().__init__()
        self.current_player = self.X
        self.board = [
            [0, 0, 0],
            [0, 0, 0],
            [0, 0, 0],
        ]

        # Our board is made up of 3 by 3 TicTacToeButtons
        # The TicTacToeButton maintains the callbacks and helps steer
        # the actual game.
        for x in range(3):
            for y in range(3):
                self.add_item(TicTacToeButton(x, y))

    # This method checks for the board winner -- it is used by the TicTacToeButton
    def check_board_winner(self):
        for across in self.board:
            value = sum(across)
            if value == 3:
                return self.O
            elif value == -3:
                return self.X

        # Check vertical
        for line in range(3):
            value = self.board[0][line] + self.board[1][line] + self.board[2][line]
            if value == 3:
                return self.O
            elif value == -3:
                return self.X

        # Check diagonals
        diag = self.board[0][2] + self.board[1][1] + self.board[2][0]
        if diag == 3:
            return self.O
        elif diag == -3:
            return self.X

        diag = self.board[0][0] + self.board[1][1] + self.board[2][2]
        if diag == 3:
            return self.O
        elif diag == -3:
            return self.X

        # If we're here, we need to check if a tie was made
        if all(i != 0 for row in self.board for i in row):
            return self.Tie

        return None

@bot.command(name="w")
async def weather(ctx, *, city_name):
    try:
        weather_data = get_weather_data(city_name)
        embed = create_weather_embed(weather_data)
        message = await ctx.send(embed=embed)

        async def more_info_callback(interaction, message=message):
            more_info_embed = create_more_info_embed(weather_data)
            await message.edit(embed=more_info_embed, view=None)

        more_info_button = Button(label="More Info", style=discord.ButtonStyle.green)
        more_info_button.callback = more_info_callback

        view = View()
        view.add_item(more_info_button)

        await message.edit(view=view)

        def check(interaction):
            return interaction.message.id == message.id

        try:
            interaction = await bot.wait_for("button_click", check=check, timeout=3600)
            await more_info_callback(interaction)
        except asyncio.TimeoutError:
            view.clear_items()
            await message.edit(view=view)

    except discord.Forbidden:
        await ctx.send(
            "–Ø –Ω–µ –º–æ–≥—É –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤–∞–º –ø—Ä–∏–≤–∞—Ç–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ. –ü–æ–∞–ª—É–π—Å—Ç–∞, —Ä–∞–∑—Ä–µ—à–∏—Ç–µ –º–Ω–µ –ø–∏—Å–∞—Ç—å –≤–∞–º."
        )


def get_weather_data(city):
    # Make API request to OpenWeatherMap
    url = f"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={WEATHER_API_KEY}&units=metric"
    response = requests.get(url)
    return response.json()


def translate_weather(value):
    match value:
        case "clear sky":
            a = "–Ø—Å–Ω–æ ‚òÄÔ∏è"
        case "few clouds":
            a = "–ù–µ–º–Ω–æ–≥–æ –æ–±–ª–∞—á–Ω–æ üå§"
        case "scattered clouds":
            a = "–†–∞—Å—Å–µ—è–Ω–Ω—ã–µ –æ–±–ª–∞–∫–∞ ‚òÅÔ∏è"
        case "broken clouds":
            a = "–û–±–ª–∞—á–Ω–æ —Å –ø—Ä–æ—è—Å–Ω–µ–Ω–∏—è–º–∏ ‚òÅÔ∏è"
        case "overcast clouds":
            a = "–ü–∞—Å–º—É—Ä–Ω–æ ‚òÅÔ∏è"
        case "mist":
            a = "–¢—É–º–∞–Ω üå´Ô∏è"
        case "fog":
            a = "–¢—É–º–∞–Ω üå´Ô∏è"
        case "haze":
            a = "–ú–≥–ª–∞ üå´Ô∏è"
        case "smoke":
            a = "–î—ã–º–∫–∞ üî•"
        case "dust":
            a = "–ü—ã–ª—å üí®"
        case "sand":
            a = "–ü–µ—Å—á–∞–Ω–∞—è –±—É—Ä—è üå™Ô∏è"
        case "ash":
            a = "–ü–µ–ø–µ–ª ‚ò†Ô∏è"
        case "squalls":
            a = "–®–∫–≤–∞–ª—ã üí®"
        case "tornado":
            a = "–¢–æ—Ä–Ω–∞–¥–æ üå™Ô∏è"
        case "tropical storm":
            a = "–¢—Ä–æ–ø–∏—á–µ—Å–∫–∏–π —à—Ç–æ—Ä–º üåÄ"
        case "hurricane":
            a = "–£—Ä–∞–≥–∞–Ω üåÄ"
        case "light rain":
            a = "–õ–µ–≥–∫–∏–π –¥–æ–∂–¥—å üåßÔ∏è"
        case "moderate rain":
            a = "–£–º–µ—Ä–µ–Ω–Ω—ã–π –¥–æ–∂–¥—å üåßÔ∏è"
        case "heavy rain":
            a = "–°–∏–ª—å–Ω—ã–π –¥–æ–∂–¥—å üåßÔ∏è"
        case "shower rain":
            a = "–õ–∏–≤–Ω–µ–≤—ã–π –¥–æ–∂–¥—å üåßÔ∏è"
        case "light snow":
            a = "–õ–µ–≥–∫–∏–π —Å–Ω–µ–≥ üå®Ô∏è"
        case "moderate snow":
            a = "–£–º–µ—Ä–µ–Ω–Ω—ã–π —Å–Ω–µ–≥ üå®Ô∏è"
        case "heavy snow":
            a = "–°–∏–ª—å–Ω—ã–π —Å–Ω–µ–≥ üå®Ô∏è"
        case "sleet":
            a = "–î–æ–∂–¥—å —Å–æ —Å–Ω–µ–≥–æ–º üå®Ô∏è"
        case "shower sleet":
            a = "–õ–∏–≤–Ω–µ–≤—ã–π –¥–æ–∂–¥—å —Å–æ —Å–Ω–µ–≥–æ–º üå®Ô∏è"
        case "light rain and snow":
            a = "–õ–µ–≥–∫–∏–π –¥–æ–∂–¥—å –∏ —Å–Ω–µ–≥ üåßÔ∏è‚ùÑÔ∏è"
        case "moderate rain and snow":
            a = "–£–º–µ—Ä–µ–Ω–Ω—ã–π –¥–æ–∂–¥—å –∏ —Å–Ω–µ–≥ üåßÔ∏è‚ùÑÔ∏è"
        case "light shower snow":
            a = "–õ–µ–≥–∫–∏–π –ª–∏–≤–Ω–µ–≤—ã–π —Å–Ω–µ–≥ üå®Ô∏è"
        case "thunderstorm with light rain":
            a = "–ì—Ä–æ–∑–∞ —Å –Ω–µ–±–æ–ª—å—à–∏–º –¥–æ–∂–¥–µ–º ‚õàÔ∏èüåßÔ∏è"
        case "thunderstorm with rain":
            a = "–ì—Ä–æ–∑–∞ —Å –¥–æ–∂–¥–µ–º ‚õàÔ∏èüåßÔ∏è"
        case "thunderstorm with heavy rain":
            a = "–ì—Ä–æ–∑–∞ —Å —Å–∏–ª—å–Ω—ã–º –¥–æ–∂–¥–µ–º ‚õàÔ∏èüåßÔ∏è"
        case "light thunderstorm":
            a = "–õ–µ–≥–∫–∞—è –≥—Ä–æ–∑–∞ ‚õàÔ∏è"
        case "moderate thunderstorm":
            a = "–£–º–µ—Ä–µ–Ω–Ω–∞—è –≥—Ä–æ–∑–∞ ‚õàÔ∏è"
        case "heavy thunderstorm":
            a = "–°–∏–ª—å–Ω–∞—è –≥—Ä–æ–∑–∞ ‚õàÔ∏è"
        case "ragged thunderstorm":
            a = "–ù–µ—Ä–æ–≤–Ω–∞—è –≥—Ä–æ–∑–∞ ‚õàÔ∏è"
        case "thunderstorm with light drizzle":
            a = "–ì—Ä–æ–∑–∞ —Å –º–æ—Ä–æ—Å—è—â–∏–º –¥–æ–∂–¥–µ–º –∏ –º–æ–ª–Ω–∏—è–º–∏ ‚õàÔ∏èüåßÔ∏è"
        case "thunderstorm with drizzle":
            a = "–ì—Ä–æ–∑–∞ —Å –º–æ—Ä–æ—Å—è—â–∏–º –¥–æ–∂–¥–µ–º ‚õàÔ∏èüåßÔ∏è"
        case "thunderstorm with heavy drizzle":
            a = "–ì—Ä–æ–∑–∞ —Å —Å–∏–ª—å–Ω—ã–º –º–æ—Ä–æ—Å—è—â–∏–º –¥–æ–∂–¥–µ–º ‚õàÔ∏èüåßÔ∏è"
        case _:
            a = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ ‚ùì"

    return a


def create_weather_embed(data):
    # Create and return a Discord embed for weather data

    embed = discord.Embed(
        title=f"–ü–æ–≥–æ–¥–∞ –≤ –≥–æ—Ä–æ–¥–µ: {data['name']}",
        description=translate_weather(data["weather"][0]["description"]),
        color=0x3498DB,
    )
    embed.add_field(name="–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞", value=f"{data['main']['temp']}¬∞C")
    embed.add_field(name="–í–ª–∞–∂–Ω–æ—Å—Ç—å", value=f"{data['main']['humidity']}%")
    embed.add_field(name="–°–∫–æ—Ä–æ—Å—Ç—å –≤–µ—Ç—Ä–∞", value=f"{data['wind']['speed']} m/s")
    return embed


def create_more_info_embed(data):
    # Create and return a Discord embed with more info

    embed = discord.Embed(
        title=f"–ë–æ–ª—å—à–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø–æ–≥–æ–¥–µ –≤: {data['name']}",
        description=translate_weather(data["weather"][0]["description"]),
        color=0x3498DB,
    )

    embed.add_field(name="–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞", value=f"{data['main']['temp']}¬∞C")
    embed.add_field(name="–í–ª–∞–∂–Ω–æ—Å—Ç—å", value=f"{data['main']['humidity']}%")
    embed.add_field(name="–°–∫–æ—Ä–æ—Å—Ç—å –≤–µ—Ç—Ä–∞", value=f"{data['wind']['speed']} m/s")
    embed.add_field(name="–î–∞–≤–ª–µ–Ω–∏–µ", value=f"{data['main']['pressure']} hPa")

    return embed


button1 = Button(label="–ò–Ω—Ñ–æ", style=discord.ButtonStyle.green)
button2 = Button(label="–ö–æ–º–∞–Ω–¥—ã", style=discord.ButtonStyle.green)
button3 = Button(label="–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", style=discord.ButtonStyle.green)


@bot.command()
async def menu(ctx):
    view = View()
    view.add_item(button1)
    view.add_item(button2)
    view.add_item(button3)

    message = await ctx.send("–ú–µ–Ω—é KnyshBoT: \n–í—ã–±–µ—Ä–∏—Ç–µ –æ–¥–∏–Ω –∏–∑ –ø—É–Ω–∫—Ç–æ–≤: ", view=view)

    async def button1_callback(interaction):
        await interaction.response.edit_message(content="„Ö§", view=None)
        await message.delete()  # Delete the menu message
        library_version = discord.__version__
        # Send an embed
        embed = discord.Embed(
            title="–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ KnyshBot",
            description="¬© 2023 D44K Local Software Corp",
            color=discord.Color.green(),
        )
        embed.add_field(name="BotOS Version", value="**ver. 0.31.2** User Experience Silent Update", inline=False)
        embed.add_field(name="GitHub Repository", value="https://github.com/De44iK/Discord-KnyshBoT")
        embed.add_field(name='Discord.Py Library Version', value=library_version, inline=False)
        await ctx.send(embed=embed)

    async def button2_callback(interaction):
        await interaction.response.edit_message(content="„Ö§", view=None)
        await message.delete()  # Delete the menu message

        await ctx.send(embed=embedCMDS)

    async def button3_callback(interaction):
        try:
            await interaction.response.edit_message(content="„Ö§", view=None)
            await message.delete()  # Delete the menu message
            server_count = len(bot.guilds)
            user_count = sum(guild.member_count for guild in bot.guilds)
            now = datetime.datetime.now(datetime.timezone.utc)
            uptime = now - bot.user.created_at
            

            days = uptime.days
            # Send an embed
            embed = discord.Embed(
                title="üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ KnyshBoT",
                description="–í–æ—Ç –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –ø–æ–∫–∞–∑–∞—Ç–µ–ª–∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞: ",
                color=discord.Color.green(),
            )
            embed.add_field(name=f'üåê –ö–æ–ª-–≤–æ –°–µ—Ä–≤–µ—Ä–æ–≤ —Å —ç—Ç–∏–º –±–æ—Ç–æ–º: {server_count}', value='', inline=False)
            embed.add_field(name=f'üë§ –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –±–æ—Ç–∞: {user_count}', value='', inline=False)
            embed.add_field(name= f"üåà –¶–≤–µ—Ç–æ–≤ –¥–ª—è –æ–±—å—è–≤–ª–µ–Ω–∏–π: {len(color_list)}",value='', inline=False)
            embed.add_field(name=f'üìÜ –ë–æ—Ç —Å—É—â–µ—Å—Ç–≤—É–µ—Ç —É–∂–µ: {str(days)} –¥.', value='', inline=False)
            embed.add_field(name= f"üíª –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ö–æ–º–∞–Ω–¥: {len(bot.commands)}", value='', inline=False)
            
            await ctx.send(embed=embed)
        except Exception as e:
            print(e)

    button1.callback = button1_callback
    button2.callback = button2_callback
    button3.callback = button3_callback


@bot.command()
async def cls(ctx):
    if ctx.channel.id == 996721226166841424:
        # Fetch the channel to clear messages from
        channel = ctx.channel

        # Fetch and delete messages in batches
        messages_deleted = 0
        async for message in channel.history(limit=None):
            await message.delete()
            messages_deleted += 1

        await ctx.send(f"Channel cleared. Deleted {messages_deleted} messages.")
    else:
        await ctx.send("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ —Ç–æ–ª—å–∫–æ –¥–ª—è –º—É–∑—ã–∫–∞–ª—å–Ω–æ–≥–æ —á–∞—Ç–∞")


@bot.command()
async def tic(ctx: commands.Context):
    """Starts a tic-tac-toe game with yourself."""
    await ctx.send("–ö—Ä–µ—Å—Ç–∏–∫–∏-–Ω–æ–ª–∏–∫–∏: –• —Ö–æ–¥–∏—Ç –ø–µ—Ä–≤—ã–º", view=TicTacToe())

# buttonA = Button(label="A", style=discord.ButtonStyle.green)
# buttonB = Button(label="B", style=discord.ButtonStyle.green)
# buttonC = Button(label="C", style=discord.ButtonStyle.green)

# @bot.command()
# async def cls1(ctx):
#     chanid = ctx.channel.id
#     clearchat()
#     async def clearchat():
#         if chanid == 996721226166841424:
#             # Fetch the channel to clear messages from
#             channel = ctx.channel

#             # Fetch and delete messages in batches
#             messages_deleted = 0
#             async for message in channel.history(limit=None):
#                 await message.delete()
#                 messages_deleted += 1

#             await ctx.send(f"Channel cleared. Deleted {messages_deleted} messages.")
#         else:
#             await ctx.send("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ —Ç–æ–ª—å–∫–æ –¥–ª—è –º—É–∑—ã–∫–∞–ª—å–Ω–æ–≥–æ —á–∞—Ç–∞. –í–≤–µ–¥–∏—Ç–µ –ê–¥–º–∏–Ω—Å–∫–∏–π –ø–∞—Ä–æ–ª—å —á—Ç–æ –±—ã –æ—á–∏—Å—Ç–∏—Ç—å —ç—Ç–æ—Ç —á–∞—Ç")
#             password = []
#             view = View()
#             view.add_item(buttonA)
#             view.add_item(buttonB)
#             view.add_item(buttonC)
#             message = await ctx.send("–ú–µ–Ω—é KnyshBoT: \n–í—ã–±–µ—Ä–∏—Ç–µ –æ–¥–∏–Ω –∏–∑ –ø—É–Ω–∫—Ç–æ–≤: ", view=view)
#             def buttonA_callback(interaction):
#                 password.append("A")
#                 if "".join(password) == "AABC":
#                     print("Password is correct!!!!")
#             def buttonB_callback(interaction):
#                 password.append("B")
#                 if "".join(password) == "AABC":
#                     print("Password is correct!!!!")
#             def buttonC_callback(interaction):
#                 password.append("C")
#                 if "".join(password) == "AABC":
#                     chanid = 996721226166841424
#                     clearchat()
#         buttonA.callback = buttonA_callback
#         buttonB.callback = buttonB_callback
#         buttonC.callback = buttonC_callback

@bot.event
async def on_ready():
    print("\033[1;32;40m"+f"Logged in SUCESSFULLY as {bot.user.name}#{bot.user.discriminator}" + "\033[0m")
    await bot.change_presence(
        activity=discord.Activity(
            type=discord.ActivityType.playing,
            name="/menu | Ver 0.31.3",
            # details="none",
            # state="¬© 2023 D44K Local Software Corp",
        )
    )

async def main():
    # await load_cogs()
    if BOT_MODE == "RELEASE":
        await bot.start(BOT_TOKEN_RELEASE)
    elif BOT_MODE == "TESTING":
        await bot.start(BOT_TOKEN_TESTING)
    else:
        print(f"> ERROR!\nINCORRECT BOT MODE IS SELECTED: {BOT_MODE}")

if __name__ == "__main__":
    asyncio.run(main())


#damn this code became long asf